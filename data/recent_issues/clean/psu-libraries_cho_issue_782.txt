Non-EDTF dates
Dates such as "1/17/19" and "January 17, 2019" are not acceptable date formats in EDTF; however, users such Dept. of Visual Resources have dates in the format. We should probably allow quasi-standardized date forms that we parse. Options Re-write non-EDTF dates for storage For example, we could re-write "1/17/19" and "January 17, 2019" as "2019-01-17" when storing the date value. This would make all dates in the system EDTF-compliant, but users would loose their original format. Something like "16th-century" would be stored as "15??" which is what the user would see when displaying or editing the form again. Persist parseable non-EDTF dates Any date parseable by Ruby or any other logic we create, can be stored, even if it's non-EDTF, because it can be exported in another format. When metadata is exported for preservation, it can be converted to iso8601 or another suitable EDTF format. For example, if a user enters "1/17/19" we can persist that string in CHO, but when it's exported, it would be written as "2019-01-17". Likewise, if the user enters "16th century" we can also persist that string, but it would be exported as the EDTF range "15??". Persist and parse anything Persist any string entered as a date, and attempt to parse it. If it can be parsed, it's indexed as a date, but the storage remains as the user entered it. It is also exported the same as it was entered. Persist and don't parse Store whatever the user enters as the "date" but don't treat it (from a system point-of-view) as a date. This is essentially just a text field labeled as some kind of date. Related Tickets Rendering dates in edit forms #794